
// .js file is generated by npm scripts compile/watch/compile-tests/... :
// Do not modify .js file

import { DraggableTable } from './DraggableTable';
declare var acquireVsCodeApi: any;

type Message = { [key: string]: any };
type EventHandler = (event: any) => void;

const vscode = acquireVsCodeApi();
function mediaSendMessage(message: Message): void {
    vscode.postMessage(message);
}

class MediaCheckbox {
	public  readonly id: string;                             // id inside message and load/save into context
	private readonly checkboxId: string;                     // id inside html
	private readonly checkboxLabelId: string;                // id inside html
	private readonly removeEltId: string;
    public  readonly editable: boolean;                      // removeable + label is writeable (so saved and loaded)
    public           htmlClasses: string = "";
    private          label: string;            // label of html checkbox
    // if null, no save/load, should be a main checkbox, recomputed by main.js
	private          value: boolean | null;
    public           htmlCheckbox: HTMLInputElement | null;        // element <checkboxId> from document
    private          htmlEditable: {          // only if editable
        htmlCheckboxLabel: HTMLInputElement,  // element <checkboxLabelId> from document
        removeButton: HTMLButtonElement;      // element <removeEltId> from document
    } | null = null;                          // never null after mediaInit IF editable

    constructor(id: string,
                label: string,
                value: boolean | null,                    // null if value is unknown
                editable: boolean) {
        this.id = id;
        this.checkboxId = `${this.id}-checkbox`;
        this.checkboxLabelId = `${this.id}-label`;
        this.removeEltId = `${this.id}-removeElt`;
        this.editable = editable;
        this.label = label;
        this.value = value;
        this.htmlCheckbox = null;  // never null after mediaInit
        this.htmlEditable = null;  // never null after mediaInit IF editable
    }
    mediaInit(): void {
        this.htmlCheckbox = document.getElementById(this.checkboxId) as HTMLInputElement;
        if (this.editable) {
            this.htmlEditable = {
                htmlCheckboxLabel: document.getElementById(this.checkboxLabelId) as HTMLInputElement,
                removeButton: document.getElementById(this.removeEltId) as HTMLButtonElement,
            };
        }
    }
    mediaAddEventListener(method: EventHandler): void {
        this.htmlCheckbox!.addEventListener('input', (event: any) => { method(event); });
    }
    mediaAddEventListenerEdit(method: EventHandler) {
        this.htmlEditable!.htmlCheckboxLabel!.addEventListener('input', (event: any) => {
            method(event);
        });
    }
    mediaAddEventListenerRemove(method: (checkbox: MediaCheckbox) => void): void {
        this.htmlEditable!.removeButton!.addEventListener('click', () => {
            // console.log("media.removeButton input");
            method(this);
        });
    }
    mediaUpdateMessage(message: Message): void {
        message[this.id] = this.htmlCheckbox!.checked;
        message[this.checkboxLabelId] = this.label;
        // console.log(this.id, `mediaUpdateMessage message[${this.id}]`, message[this.id], `message[${this.checkboxLabelId}]`, message[this.checkboxLabelId]);
    }
    mediaEditValid(managerId: string): void {
        // Save
        this.label = this.htmlEditable!.htmlCheckboxLabel!.value!;
        // console.log("mediaEditValid", "this.label", this.label);

        // Send mod message
        const message: Message = {
            manager: managerId,
            command: 'mod',
            eltId: this.id,
        };
        this.mediaUpdateMessage(message);
        // console.log("mediaEditValid mediaSendMessage", message);
        mediaSendMessage!(message);
    }

    getHtmls(): string[] {
        const classDecl = this.htmlClasses !== '' ? `class="${this.htmlClasses}"` : '';
        const state = this.value ? "checked" : "";
        const labelHtml = this.editable ?
            `<input for="${this.checkboxId}" id="${this.checkboxLabelId}" type="text" value="${this.label}" placeholder="*.cpp,*.c,*.h" class="input-as-label"/>` : 
            `<label for="${this.checkboxId}" id="${this.checkboxLabelId}">${this.label}</label>`;

        const html = `<div class="container">
                      <input type="checkbox" ${state} id="${this.checkboxId}" ${classDecl} />
                      ${labelHtml}
                      </div>`;
        // TODO click on input this.checkboxLabelId does NOT change this.checkboxId (as it does for a label)
        const htmls = [html];
        if (this.editable) {
            // remove button
            htmls.push(`<button id="${this.removeEltId}">&#10134;</button>`);
            // drag&drop
            htmls.push("=");
        }
        return htmls;
    }
}

class MediaCheckboxManager {
    private readonly id: string;
    private readonly addEltId: string;
	private readonly mainElt: MediaCheckbox;  // All checkbox permits to select/unselect all elts
	private readonly elts: MediaCheckbox[];
    private readonly autonomous: boolean;
    private readonly htmlTable: boolean;
    private          eventListenerFocusMethod: any; // null until mediaAddEventListener
    private          eventListenerSendMethod: any;  // null until mediaAddEventListener, still null if autonomous

    private          editable: {                // only if editable
        addElt: MediaCheckboxAdd;
        draggableTable: DraggableTable;
    } | null = null;

	constructor(id: string,
                mainEltLabel: string,
                editable: boolean = false,
                autonomous: boolean = false) {
        this.id = id;
        this.addEltId = `${this.id}-addElt`;
        this.elts = [];
        this.autonomous = autonomous;
        this.htmlTable = editable;
        {
            // Elts are builded/added dynamically
            //  from div generated by src 
            const srcGroup = document.getElementById(this.id) as HTMLElement;

            // Create a table or a div and replace the srcGroup
            const newGroup: HTMLElement = document.createElement('div');
            newGroup.id = this.id;
            newGroup.innerHTML = this.mediaGetHtml();
            srcGroup.parentNode!.replaceChild(newGroup, srcGroup);

            // Add the All checkbox
            this.mainElt = this.mediaAddNewChildNoMessage(id, "Main", mainEltLabel, false, false);

            // Add all elements as specified into srcGroup
            const descendants = srcGroup.getElementsByTagName("*");
            for (const idx in descendants) {
                const htmlElt = descendants[idx] as HTMLElement;
                if (! (htmlElt instanceof HTMLElement)) {
                    // console.log(this.id, `MediaCheckboxManager htmlElt`, htmlElt, "ignored");
                    continue;
                }
                const id = htmlElt.getAttribute("id")!;
                const label = htmlElt.getAttribute("label")!;
                const value = htmlElt.getAttribute("value")! === "true";
                const editable = htmlElt.getAttribute("editable")! === "true";
                // console.log(this.id, `MediaCheckboxManager Elt ${label} ${value} ${editable}`, htmlElt);

                this.mediaAddNewChildNoMessage(id, "Elt",  label, value, editable);
            }
            if (editable) {
                this.editable = {
                    addElt: new MediaCheckboxAdd(this, this.addEltId),
                    draggableTable: new DraggableTable(`${id}-draggable-table`, (row) => this.mediaRowDropped(row)),
                };
                this.mediaAddNewChildHtml(this.addEltId, this.editable.addElt.getHtmls());
                this.editable.addElt.mediaInit();
                this.editable.addElt.mediaAddEventListener((event: any) => {
                    this.eventListenerFocusMethod(event);
                });
            }
            const firstStart = srcGroup.getAttribute("first-start")! === "true";
            if (firstStart && this.elts.length === 0) {
                this.mediaOnFirstStart();
            }
        }
        this.mediaComputeMainCheckbox();
        this.eventListenerFocusMethod = null;
        this.eventListenerSendMethod = null;
    }
    protected mediaOnFirstStart(): void {
        // To override if needed
        // E.g. add some default elts
    }
    mediaGetHtml(): string {
        let html = "";
        if (this.htmlTable) {
            html += `<table id="${this.id}-draggable-table" class="draggable-table">`;
            html += `<tbody>`;
            html += `</tbody>`;
            html += `</table>`;
        }
        return html;
    }
    mediaRowDropped(_row: Element): void {
        // console.log(this.id, "mediaRowDropped", row);

        // Retrieve the new order of the rows
        const eltIds: string[] = [];
        {
            const srcGroup = document.getElementById(this.id) as HTMLElement;
            const descendants = srcGroup.getElementsByClassName("subCheckbox");
            for (const idx in descendants) {
                const htmlElt = descendants[idx] as HTMLElement;
                if (! (htmlElt instanceof HTMLElement)) {
                    // console.log(this.id, `MediaCheckboxManager htmlElt`, htmlElt, "ignored");
                    continue;
                }
                const id = htmlElt.getAttribute("id")!;
                eltIds.push(id.replace('-checkbox', ''));
            }
        }

        // Send list message
        const message: Message = {
            manager: `${this.id}`,
            command: 'list-order',
             eltIds: eltIds,
        };
        // console.log(this.id, "mediaRowDropped mediaSendMessage", message);
        mediaSendMessage!(message);

        // Sort this.elts is useless
    }
    mediaRemoveChild(elt: MediaCheckbox): void {
        // console.log(this.id, "mediaRemoveChild", elt);

        // Send remove message
        const message: Message = {
            manager: `${this.id}`,
            command: 'remove',
        };
        message[elt.id] = true;
        // console.log(this.id, "mediaRemoveChild mediaSendMessage", message);
        mediaSendMessage!(message);

        // Remove html
        const eltHtml = document.getElementById( `${elt.id}-elt`)!;
        eltHtml.parentNode!.removeChild(eltHtml);
        
        // Remove elt from this
        const index = this.elts.indexOf(elt, 0);
        // console.log(this.id, "mediaRemoveChild index", index);
        this.elts.splice(index, 1);

        this.mediaComputeMainCheckbox();
    }
    mediaAddNewChild(label: string, value: boolean): MediaCheckbox {
        const eltId = this.mediaGenerateNewChildId();
        // console.log(this.id, "mediaAddNewChild", eltId);
        const elt = this.mediaAddNewChildNoMessage(eltId, "Elt", label, value, true);

        this.mediaComputeMainCheckbox();

        // Send add message
        const message: Message = {
            manager: `${this.id}`,
            command: 'add',
            eltIdToAdd: eltId,
        };
        elt.mediaUpdateMessage(message);
        // console.log(this.id, "mediaAddNewChild mediaSendMessage", message);
        mediaSendMessage!(message);

        return elt;
    }
    private mediaGenerateNewChildId(): string {
        let max = -1;
        for (const elt of this.elts) {
            const subIdStr = elt.id.split('-')[1];
            const subId: number = +subIdStr;
            max = Math.max(max, subId);
        }
        return `${this.id}-${max+1}`;
    }
    private mediaAddNewChildNoMessage(eltId: string, kind: string, label: string, value: boolean, editable: boolean): MediaCheckbox {
        // console.log(this.id, "mediaAddNewChildNoMessage", eltId);
        const elt = new MediaCheckbox(eltId, label, value, editable);
        if (kind === "Elt") {
            elt.htmlClasses = "subCheckbox";
        }
        const eltHtmls = elt.getHtmls();
        // console.log(this.id, "mediaAddNewChildNoMessage", eltId, eltHtmls);

        // Add html into document
        this.mediaAddNewChildHtml(kind === "Elt" ? `${eltId}-elt` : `${eltId}-mainElt`, eltHtmls);

        // Init new element from html
        elt.mediaInit();
        if (kind === "Elt") {
            this.elts.push(elt);
        }

        // Add listener
        this.mediaEltAddEventListener(elt);

        return elt;
    }
    private mediaAddNewChildHtml(eltId: string, eltHtmls: string[]): void {
        // console.log(this.id, "mediaAddNewChildHtml", eltId, eltHtmls);

        // Add html into document
        const newRow: HTMLElement = document.createElement(this.htmlTable ? 'tr' : 'div');
        newRow.id = eltId;
        newRow.innerHTML = this.getHtmlEltRaw(eltId, eltHtmls);

        let parent = document.getElementById(this.id)!;
        if (this.htmlTable) {
            parent = parent.getElementsByTagName('tbody')[0];
        }

        if (parent.hasChildNodes() === false) {
            // 1st child, should be main checkbox
            parent.insertBefore(newRow, null);
        }
        else {
            // not 1st child, should be elt checkbox or add checkbox
            const rowBeforeId = this.elts.length > 0 ? `${this.elts.at(-1)!.id}-elt` : `${this.mainElt.id}-mainElt`;
            const rowBefore = document.getElementById(rowBeforeId)!;
            // console.log(`rowBeforeId=${rowBeforeId} rowBefore=${rowBefore}`);
            rowBefore.parentNode!.insertBefore(newRow, rowBefore.nextSibling);
        }
    }
    mediaEltAddEventListener(elt: MediaCheckbox): void {
        elt.mediaAddEventListener((event: any) => { this.mediaEventListenerInnerMethod(event); });
        if (elt.editable) {
            elt.mediaAddEventListenerEdit((event: any) => {
                // console.log(this.id, "mediaAddEventListenerEdit", elt.id);
                this.eventListenerFocusMethod(event);
                elt.mediaEditValid(this.id);
            });
            elt.mediaAddEventListenerRemove((_elt: MediaCheckbox) => {
                this.eventListenerFocusMethod(null);
                this.mediaRemoveChild(elt);
            });
        }
    }
    mediaAddEventListener(focusMethod: EventHandler, sendMethod: any): void {
        this.eventListenerFocusMethod = focusMethod;
        this.eventListenerSendMethod = sendMethod;
        // eventListeners already setted
    }
    private mediaEventListenerInnerMethod(event: any): void {
        this.mediaManage(event);
        this.eventListenerFocusMethod(event);

        if (this.eventListenerSendMethod) {
            // console.log(this.id, "mediaAddEventListenerInner callback call method");
            this.eventListenerSendMethod(event);
        }
        else {
            // console.log(this.id, "mediaAddEventListenerInner callback call mediaBuildMessage");
            const message = this.mediaBuildMessage();
            mediaSendMessage!(message);
        }
    }
    mediaUpdateMessage(message: Message): void {
        if (this.autonomous) {
            console.error(this.id, "mediaUpdateMessage must not be called if autonomous");
        }

        for (const elt of this.elts) {
            elt.mediaUpdateMessage(message);
        }
    }
    private mediaBuildMessage(): {} {
        if (!this.autonomous) {
            console.error(this.id, "mediaBuildMessage must not be called if not autonomous");
        }

        const message = {
            manager: `${this.id}`,
            command: 'exec',
        };

        for (const elt of this.elts) {
            elt.mediaUpdateMessage(message);
        }
        return message;
    }

    private mediaManage(event: any): void {
        if (this.mainElt.htmlCheckbox === event.target) {
            // Change all subCheckboxes
            for (const elt of this.elts) {
                if (elt.htmlCheckbox) {
                    elt.htmlCheckbox.checked = event.target?.checked;
                }
            }
            return;
        }

        for (const elt of this.elts) {
            if (elt.htmlCheckbox === event.target) {
                this.mediaComputeMainCheckbox();
                return;
            }
        }

        // Impossible
    }

    private mediaComputeMainCheckbox(): void {
        if (this.mainElt && this.mainElt.htmlCheckbox) {
            const allChecked = this.elts.length !== 0 && [...this.elts].every(elt => elt.htmlCheckbox!.checked);
            this.mainElt.htmlCheckbox.checked = allChecked;
        }
    }

    private getHtmlEltRaw(_eltId: string, eltHtmls: string[]): string {
        let html = "";
        if (this.htmlTable) {
            for (const eltHtml of eltHtmls) {
                if (eltHtml === "=") {
                    // &#8661;      https://www.w3schools.com/charsets/tryit.asp?deci=8661      large bold arrow
                    // &#8691;      https://www.w3schools.com/charsets/tryit.asp?deci=8691      large arrow
                    // &#8693;      https://www.w3schools.com/charsets/tryit.asp?deci=8693      double arrow
                    // &#8597;      https://www.w3schools.com/charsets/tryit.asp?deci=8597
                    // html += `<td class="draggable-handler">&#8597;</td>`;
                    html += `<td class="draggable-handler"><i class="codicon codicon-gripper draggable-handler"/></td>`;
                }
                else {
                    html += `<td>${eltHtml}</td>`;
                }
            }
        }
        else {
            for (const eltHtml of eltHtmls) {
                html += `<div>${eltHtml}</div>`;
            }
        }
        return html;
    }
}

class MediaCaseManager extends MediaCheckboxManager {
	constructor() {
        super("case", 'All');
    }
}

class MediaWordManager extends MediaCheckboxManager {
    constructor() {
        super("word", 'Whole word');
    }
}

class MediaCheckboxAdd {
    private readonly manager: MediaCheckboxManager;
	private readonly id: string;                             // id inside message and load/save into context
    private readonly htmlApplyId: string;
    private          media: {
        button: HTMLButtonElement;
    } | null = null;                  // never null after mediaInit

    constructor(manager: MediaCheckboxManager, id: string) {
        this.manager = manager;
        this.id = id;
        this.htmlApplyId = `${this.id}-apply`;
    }

    mediaInit(): void {
        this.media = {
            button: document.getElementById(this.htmlApplyId)  as HTMLButtonElement,
        };
    }
    mediaAddEventListener(method: EventHandler): void {
        this.media!.button.addEventListener('click', (event) => {
            // console.log(this.id, "mediaAddEventListener button click");
            method(event);
            this.manager.mediaAddNewChild("", false);
        });
    }

    getHtmls(): string[] {
        const htmls = [];
        htmls.push(``);  // no checkbox/label
        htmls.push(`<button id="${this.htmlApplyId}">&#10133;</button>`);
        return htmls;
    }
}

class MediaFilesToManager extends MediaCheckboxManager {
    constructor(id: string) {
        super(id, "All", true, true);
    }
}

class MediaFilesToIncludeManager extends MediaFilesToManager {
    constructor() {
        super("filesToInclude");
    }
    protected mediaOnFirstStart(): void {
        this.mediaAddNewChild("*.cpp,*.c,*.h", false);
        this.mediaAddNewChild("*.js,*.ts", false);
        this.mediaAddNewChild("*.java,*.kt", false);
        this.mediaAddNewChild("*.py", false);
        this.mediaAddNewChild("*.ini,*.conf", false);
        this.mediaAddNewChild("*.xml,*.json,*.yml", false);
    }
}

class MediaFilesToExcludeManager extends MediaFilesToManager {
    constructor() {
        super("filesToExclude");
    }
    protected mediaOnFirstStart(): void {
        this.mediaAddNewChild("*.o,*.a,*.dll,*.pyc", false);
        this.mediaAddNewChild("*.log,*.logs", false);
    }
}

// Defines some parts of the mmi
export class MediaMmi {
    private readonly textToSearch: HTMLInputElement;
    private readonly sensitiveCase: HTMLInputElement;
    private readonly caseManager: MediaCaseManager;
    private readonly wordManager: MediaWordManager;
    private readonly filesToIncludeManager: MediaFilesToIncludeManager;
    private readonly filesToExcludeManager: MediaFilesToExcludeManager;
    private readonly managers: MediaCheckboxManager[];
    private readonly mainManagers: MediaCheckboxManager[];
    private readonly otherManagers: MediaCheckboxManager[];
    private          focusItem: HTMLElement | null = null;

	constructor() {
        this.textToSearch  = document.getElementById('text-to-search')! as HTMLInputElement;
        this.sensitiveCase = document.getElementById('sensitive-case')! as HTMLInputElement;
        this.caseManager           = new MediaCaseManager();
        this.wordManager           = new MediaWordManager();
        this.filesToIncludeManager = new MediaFilesToIncludeManager();
        this.filesToExcludeManager = new MediaFilesToExcludeManager();
        this.mainManagers  = [this.caseManager, this.wordManager];
        this.otherManagers = [this.filesToIncludeManager, this.filesToExcludeManager];
        this.managers      = this.mainManagers.concat(this.otherManagers);

        // Focus on textToSearch at beginning (idem vscode search)
        this.textToSearch.focus();
        // Text selected (idem vscode search), so can user can paste a new text
        this.textToSearch.selectionStart = 0;
        this.textToSearch.selectionEnd = 10000;
        // At beginning, includes switch editor tab
    }

    mediaInit(): void {
        this.textToSearch.addEventListener( 'input', (event: any) => { this.mediaSaveFocusItem(event);
                                                                       this.mediaSearchIncremental(event); });
        this.sensitiveCase.addEventListener('input', (event: any) => { this.mediaSaveFocusItem(event);
                                                                       this.mediaSearchIncremental(event); });
        for (const manager of this.mainManagers) {
            manager.mediaAddEventListener((event: any) => { this.mediaSaveFocusItem(event); },
                                          (event: any) => { this.mediaSearchIncremental(event); });
        }
        for (const manager of this.otherManagers) {
            manager.mediaAddEventListener((event: any) => { this.mediaSaveFocusItem(event); }, null);
        }

        // Handle messages sent from the extension to the webview
        window.addEventListener('message', event => {
            const message = event.data; // The json data that the extension sent
            switch (message.command) {
                case 'focus':
                    // Focus comes back to the item which has triggered the command
                    this.focusItem?.focus();
                    break;
            }
        });
    }
    private mediaSaveFocusItem(event: any): void {
        this.focusItem = event ? event.target : null;
    }
    private mediaSearchIncremental(event: any): void {
        this.focusItem = event.target;

        const message = {
            command:           'main-instant',
            sensitiveCase:     this.sensitiveCase.checked,
            text:              this.textToSearch.value,
        };
        for (const manager of this.mainManagers) {
            manager.mediaUpdateMessage(message);
        }

        vscode.postMessage(message);        
    }
}
